import sys
from dataclasses import dataclass
from pathlib import Path

import mlflow
import numpy as np
import torch
import tyro
import yaml
from matplotlib import pyplot as plt
from matplotlib.colorbar import Colorbar
from matplotlib.colors import ListedColormap

sys.path
sys.path.append(".")
sys.path.append("./nerfstudio")

from nerfstudio.engine.trainer import TrainerConfig  # noqa: E402
from nerfstudio.pipelines.base_pipeline import VanillaPipeline  # noqa: E402
from nerfstudio.utils.rich_utils import CONSOLE  # noqa: E402


@dataclass
class AccessCLIArgs:
    """Stores input arguments used for accessing a model."""

    model_uri: str
    """Path to model."""
    dataset_path: Path = None
    """Path to a dataset containing a transforms.json file generated by COLMAP.
    Used to query the dataset first pose to generate a spiral trajectory"""


def get_trainer(model_path: Path) -> TrainerConfig:
    """Get the trainer config associated to the model in `model_path`.

    :return: the trainer config that correspond to the model at `model_path`
    """
    render_config_paths = list(model_path.rglob("config.yml"))

    if len(render_config_paths) == 0:
        raise RuntimeError("No model found at path", model_path)

    with open(render_config_paths[0], "r") as stream:
        config = yaml.load(stream, Loader=yaml.Loader)
    assert isinstance(config, TrainerConfig)

    return config


def load_model(
    model_path: Path,
    data_path: Path,
) -> tuple[VanillaPipeline, TrainerConfig]:
    config = get_trainer(model_path)

    # Get model state
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    checkpoint_path = list(model_path.rglob("*.ckpt"))[-1]
    loaded_state = torch.load(checkpoint_path, map_location=device)

    config.pipeline.datamanager.data = data_path

    # create pipeline from the config file content
    pipeline = config.pipeline.setup(device=device, test_mode="inference")
    pipeline.eval()
    pipeline.load_pipeline(loaded_state["pipeline"], loaded_state["step"])

    return pipeline, config


def set_colorbar(colorbar: Colorbar) -> None:
    colorbar.ax.get_yaxis().set_ticks([])
    for j, lab in enumerate(["Wall", "Background", "Roof", "Window"]):
        colorbar.ax.text(
            1.3,
            (2 * j + 1) / 2.70,
            lab,
            ha="center",
            va="center",
            rotation=270,
        )


def plot_colormap(
    metric: torch.Tensor,
    x_mesh: np.ndarray,
    y_mesh: np.ndarray,
    nbr_points: int,
    cMap: ListedColormap,
):
    fig, ax = plt.subplots()
    metric = metric.reshape((nbr_points, nbr_points))
    x_mesh = x_mesh.reshape((nbr_points, nbr_points))
    y_mesh = y_mesh.reshape((nbr_points, nbr_points))
    plot_colormap = ax.pcolormesh(
        x_mesh,
        y_mesh,
        metric.cpu(),
        # cmap=cMap,
    )
    return fig, ax, plot_colormap


def main() -> None:
    tyro.extras.set_accent_color("bright_yellow")
    param = tyro.cli(AccessCLIArgs)

    pipeline, config = load_model(
        Path(param.model_uri),
        param.dataset_path,
    )
    model = pipeline.model

    nbr_points = 768
    # x_list = np.linspace(-0.5, 1.5, nbr_points)
    # y_list = np.linspace(-1.5, 0.5, nbr_points)
    x_list = np.linspace(-7.2, 7.2, nbr_points)
    y_list = np.linspace(-7.2, 7.2, nbr_points)

    x_mesh, y_mesh = np.meshgrid(x_list, y_list)
    x_mesh = x_mesh.reshape((nbr_points**2, 1))
    y_mesh = y_mesh.reshape((nbr_points**2, 1))

    # z_list = np.linspace(0, 0.42, nbr_points)
    # z_list = np.linspace(-0.3, 0, 30)
    z_list = np.linspace(0, 15, nbr_points)
    building_labels = {0: 0, 3: 0}  # 0: wall, 3: window
    for z in z_list:
        # Get a meshgrid in x-y plain
        positions = np.concatenate(
            [x_mesh, y_mesh, z * np.ones((nbr_points**2, 1))], axis=1
        )
        positions = torch.Tensor(positions)

        # Infer density
        model.field.eval()

        positions = positions.to(torch.device("cuda:0"))

        hidden_output = model.field.forward_geonetwork(positions)

        sdf, geo_feature = torch.split(
            hidden_output, [1, model.field.config.geo_feat_dim], dim=-1
        )

        sdf = sdf.detach().cpu().numpy()

        semantic_input = geo_feature.view(-1, model.field.config.geo_feat_dim)

        semantic = model.field.mlp_semantic(semantic_input)
        semantic = model.field.field_head_semantic(semantic)

        semantic_labels = torch.argmax(
            torch.nn.functional.softmax(semantic, dim=-1), dim=-1
        )
        indexes = np.where(np.equal(np.isclose(sdf, 0, atol=0.0075), False))[0]
        semantic_labels[indexes] = 1
        semantic_labels = (
            semantic_labels.reshape((nbr_points, nbr_points)).detach().cpu().numpy()
        )

        # Detect walls and windows in the x-y plain
        for side in range(4):
            side_labels = {0: 0, 3: 0}
            for i in range(nbr_points):
                for j in range(nbr_points):
                    if side == 0:
                        label = semantic_labels[i, j]
                    elif side == 1:
                        label = semantic_labels[j, i]
                    elif side == 2:
                        label = semantic_labels[i, nbr_points - j - 1]
                    elif side == 3:
                        label = semantic_labels[nbr_points - j - 1, i]

                    if label == 1:
                        continue
                    elif label == 0 or label == 3:
                        building_labels[label] += 1
                        side_labels[label] += 1
                    break

            # if side_labels[3] != 0:
            #     CONSOLE.print(side_labels)
            #     CONSOLE.print(
            #         "WWR = ",
            #         side_labels[3] / (side_labels[0] + side_labels[3]),
            #     )

    CONSOLE.print(building_labels)
    CONSOLE.print("WWR = ", building_labels[3] / building_labels[0])
    CONSOLE.print(
        "WWR = ", building_labels[3] / (building_labels[0] + building_labels[3])
    )


if __name__ == "__main__":
    main()
